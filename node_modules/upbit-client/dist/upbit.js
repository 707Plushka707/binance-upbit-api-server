"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Upbit = void 0;
var axios_1 = __importDefault(require("axios"));
var jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
var querystring_1 = __importDefault(require("querystring"));
var crypto_1 = __importDefault(require("crypto"));
var uuid_1 = require("uuid");
var Upbit = /** @class */ (function () {
    function Upbit(auth) {
        var _this = this;
        /** Keys */
        this.access_key = (auth === null || auth === void 0 ? void 0 : auth.access_key) || '';
        this.secret_key = (auth === null || auth === void 0 ? void 0 : auth.secret_key) || '';
        /** HTTP Request */
        this.http = axios_1.default.create({ baseURL: 'https://api.upbit.com' });
        this.http.interceptors.request.use(function (value) {
            if (_this.access_key && _this.secret_key) {
                var token = value.data ? _this.GenerateToken(value.data) : _this.GenerateToken();
                value.headers['Authorization'] = "Bearer " + token;
            }
            return value;
        });
        this.http.interceptors.response.use(function (res) {
            if (res.headers['remaining-req']) {
                var remaining_req = res.headers['remaining-req'];
            }
            return res.data;
        }, function (err) {
            var _a;
            if ((_a = err.response) === null || _a === void 0 ? void 0 : _a.data) {
                throw err.response.data.error;
            }
            throw err;
        });
    }
    Upbit.prototype.GenerateToken = function (data) {
        var payload = {
            access_key: this.access_key,
            nonce: uuid_1.v4()
        };
        if (data) {
            var query = querystring_1.default.stringify(data);
            var queryHash = crypto_1.default.createHash('sha512').update(query, 'utf-8').digest('hex');
            payload.query_hash = queryHash;
            payload.query_hash_alg = 'SHA512';
        }
        return jsonwebtoken_1.default.sign(payload, this.secret_key);
    };
    /**
     * @description API 키 리스트 조회 - API 키 목록 및 만료 일자를 조회합니다.
     * @example
     * const upbit = new Upbit({ ... })
     * const keys = await upbit.GetApiKeys()
     *
     */
    Upbit.prototype.GetApiKeys = function () {
        return this.http.get('/v1/api_keys');
    };
    /**
     * @description 입출금 현황 - 입출금 현황 및 블록 상태를 조회합니다. 입출금 현황 API에서 제공하는 입출금 상태, 블록 상태 정보는 수 분 정도 지연되어 반영될 수 있습니다. 본 API는 참고용으로만 사용하시길 바라며 실제 입출금을 수행하기 전에는 반드시 업비트 공지사항 및 입출금 현황 페이지를 참고해주시기 바랍니다.
     * @example
     * const upbit = new Upbit({ ... })
     * const wallets = await upbit.GetStatusWallet()
     * [
         {
           currency: 'BTC', 화폐를 의미하는 영문 대문자 코드
           wallet_state: 'working', 입출금 상태
           block_state: 'normal', 블록 상태
           block_height: 665700, block_height	블록 높이	Integer
           block_updated_at: '2021-01-01T09:00:00.000+00:00', block_updated_at	블록 갱신 시각
           block_elapsed_minutes: 20
         }
       ]
       입출금 상태
       - working : 입출금 가능
       - withdraw_only : 출금만 가능
       - deposit_only : 입금만 가능
       - paused : 입출금 중단
       - unsupported : 입출금 미지원
   
       블록 상태
       - normal : 정상
       - delayed : 지연
       - inactive : 비활성 (점검 등)
     */
    Upbit.prototype.GetStatusWallet = function () {
        return this.http.get('/v1/status/wallet');
    };
    /**
     * @description 전체 입금 주소 조회 - 내가 보유한 자산 리스트를 보여줍니다.
     * @example
     * const upbit = new Upbit({ ... })
     * const addresses = await upbit.GetDepositsCoinAddresses()
     * const address = await upbit.GetDepositsCoinAddresses({ currency: 'BTC' })
     *
     */
    Upbit.prototype.GetDepositsCoinAddresses = function (data) {
        return this.http.get('/v1/deposits/coin_addresses?' + querystring_1.default.stringify(data), {
            data: data
        });
    };
    /**
     * @description 전체 계좌 조회 - 내가 보유한 자산 리스트를 보여줍니다.
     * @example
     * const upbit = new Upbit({ ... })
     * const accounts = await upbit.GetAccounts()
     *
     * currency - 화폐를 의미하는 영문 대문자 코드
     *
       balance - 주문가능 금액/수량
  
       locked - 주문 중 묶여있는 금액/수량
  
       avg_buy_price - 매수평균가
  
       avg_buy_price_modified - 매수평균가 수정 여부
  
       unit_currency - 평단가 기준 화폐
     */
    Upbit.prototype.GetAccounts = function () {
        return this.http.get('/v1/accounts');
    };
    /**
     * @description 업비트에서 거래 가능한 마켓 목록
     * @example
     * const upbit = new Upbit({ ... })
     * const accounts = await upbit.GetMarketCode()
     * [
     *   {
     *     market: 'KRW-BTC',
     *     korean_name: '비트코인',
     *     english_name: 'Bitcoin'
     *   }
     * ]
     *
     * market - 업비트에서 제공중인 시장 정보
     *
     * korean_name - 거래 대상 암호화폐 한글명
     *
     * english_name - 거래 대상 암호화폐 영문명
     */
    Upbit.prototype.GetMarketCodes = function (options) {
        return this.http.get('/v1/market/all', { params: options });
    };
    /**
     * @description 주문하기
     * const upbit = new Upbit({ ... })
     * const order = await upbit.Order({ market: 'KRW-BTC', side: 'ask', volume: '0.01', price: '100, ord_type: 'limit' })
     *
     */
    Upbit.prototype.Order = function (data) {
        return this.http.post('/v1/orders', { data: data });
    };
    /**
     *  @description 매도 가능 여부 조회하기
     *  @param market 마켓명
     *  @example
     *  const upbit = new Upbit({ ... })
     *  const chance = await upbit.GetOrderChance('KRW-BTC')
     *
     *
     *  bid_fee	매수 수수료 비율	NumberString
        ask_fee	매도 수수료 비율	NumberString
        market	마켓에 대한 정보	Object
        market.id	마켓의 유일 키	String
        market.name	마켓 이름	String
        market.order_types	지원 주문 방식	Array[String]
        market.order_sides	지원 주문 종류	Array[String]
        market.bid	매수 시 제약사항	Object
        market.bid.currency	화폐를 의미하는 영문 대문자 코드	String
        market.bit.price_unit	주문금액 단위	String
        market.bid.min_total	최소 매도/매수 금액	Number
        market.ask	매도 시 제약사항	Object
        market.ask.currency	화폐를 의미하는 영문 대문자 코드	String
        market.ask.price_unit	주문금액 단위	String
        market.ask.min_total	최소 매도/매수 금액	Number
        market.max_total	최대 매도/매수 금액	NumberString
        market.state	마켓 운영 상태	String
        bid_account	매수 시 사용하는 화폐의 계좌 상태	Object
        bid_account.currency	화폐를 의미하는 영문 대문자 코드	String
        bid_account.balance	주문가능 금액/수량	NumberString
        bid_account.locked	주문 중 묶여있는 금액/수량	NumberString
        bid_account.avg_buy_price	매수평균가	NumberString
        bid_account.avg_buy_price_modified	매수평균가 수정 여부	Boolean
        bid_account.unit_currency	평단가 기준 화폐	String
        ask_account	매도 시 사용하는 화폐의 계좌 상태	Object
        ask_account.currency	화폐를 의미하는 영문 대문자 코드	String
        ask_account.balance	주문가능 금액/수량	NumberString
        ask_account.locked	주문 중 묶여있는 금액/수량	NumberString
        ask_account.avg_buy_price	매수평균가	NumberString
        ask_account.avg_buy_price_modified	매수평균가 수정 여부	Boolean
        ask_account.unit_currency	평단가 기준 화폐	String
     */
    Upbit.prototype.GetOrderChance = function (market) {
        return this.http.get('/v1/orders/chance?' + querystring_1.default.stringify({ market: market }), {
            data: { market: market }
        });
    };
    /**
     * @description 주문 정보 조회하기
     * @param uuid 주문했을 때 사용한 uuid.
     * @example
     * const upbit = new Upbit({ ... })
     * const order = await upbit.Order({ market: 'KRW-BTC', side: 'ask', volume: '0.01', price: '100, ord_type: 'limit' })
     */
    Upbit.prototype.GetOrder = function (uuid) {
        return this.http.get("/v1/order?" + querystring_1.default.stringify({ uuid: uuid }), {
            data: { uuid: uuid }
        });
    };
    /**
     *
     * @param uuids Name	설명	타입
     * @param state
     * market	마켓 아이디	String
        uuids	주문 UUID의 목록	Array
        identifiers	주문 identifier의 목록	Array
        state	주문 상태
        - wait : 체결 대기 (default)
        - done : 전체 체결 완료
        - cancel : 주문 취소	String
        states	주문 상태의 목록	Array
        kind	주문 유형
        - normal : 일반 주문
        - watch : 예약 주문	String
        page	페이지 수, default: 1	Number
        limit	요청 개수, default: 100	Number
        order_by	정렬 방식
        - asc : 오름차순
        - desc : 내림차순 (default)	String
     */
    Upbit.prototype.GetOrders = function (data) {
        return this.http.get('/v1/orders?' + querystring_1.default.stringify(data), { data: data });
    };
    Upbit.prototype.GetCandleByMinute = function (data) {
        var payload = {
            market: data.market,
            count: data.count || 1
        };
        switch (data === null || data === void 0 ? void 0 : data.unit) {
            case 1:
            case 3:
            case 5:
            case 10:
            case 15:
            case 30:
            case 60:
            case 240:
                break;
            default:
                throw new Error('Invalid unit.');
        }
        if (data.count) {
            if (data.count > 200) {
                throw new Error('Invalid count.');
            }
        }
        if (data.to)
            [(payload.to = data.to)];
        return this.http.get("/v1/candles/minutes/" + (data.unit || 1) + "?" + querystring_1.default.stringify(data), { data: data });
    };
    /**
     * @description 최근 체결 내역
     */
    Upbit.prototype.GetTrades = function (data) {
        return this.http.get('/v1/trades/ticks?' + querystring_1.default.stringify(data), { data: data });
    };
    /**
     * @description 현재가 정보 - 요청 당시 종목의 스냅샷을 반환한다.
     * @param markets 마켓명의 배열
     * @example
     *
     */
    Upbit.prototype.GetTickers = function (markets) {
        return this.http.get("/v1/ticker?markets=" + markets.join(), {
            data: { markets: markets.join() }
        });
    };
    return Upbit;
}());
exports.Upbit = Upbit;
